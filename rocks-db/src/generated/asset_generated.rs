// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::{cmp::Ordering, mem};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod asset {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SPECIFICATION_ASSET_CLASS: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SPECIFICATION_ASSET_CLASS: i8 = 11;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SPECIFICATION_ASSET_CLASS: [SpecificationAssetClass; 12] = [
        SpecificationAssetClass::Unknown,
        SpecificationAssetClass::FungibleToken,
        SpecificationAssetClass::FungibleAsset,
        SpecificationAssetClass::Nft,
        SpecificationAssetClass::PrintableNft,
        SpecificationAssetClass::ProgrammableNft,
        SpecificationAssetClass::Print,
        SpecificationAssetClass::TransferRestrictedNft,
        SpecificationAssetClass::NonTransferableNft,
        SpecificationAssetClass::IdentityNft,
        SpecificationAssetClass::MplCoreAsset,
        SpecificationAssetClass::MplCoreCollection,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SpecificationAssetClass(pub i8);
    #[allow(non_upper_case_globals)]
    impl SpecificationAssetClass {
        pub const Unknown: Self = Self(0);
        pub const FungibleToken: Self = Self(1);
        pub const FungibleAsset: Self = Self(2);
        pub const Nft: Self = Self(3);
        pub const PrintableNft: Self = Self(4);
        pub const ProgrammableNft: Self = Self(5);
        pub const Print: Self = Self(6);
        pub const TransferRestrictedNft: Self = Self(7);
        pub const NonTransferableNft: Self = Self(8);
        pub const IdentityNft: Self = Self(9);
        pub const MplCoreAsset: Self = Self(10);
        pub const MplCoreCollection: Self = Self(11);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 11;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Unknown,
            Self::FungibleToken,
            Self::FungibleAsset,
            Self::Nft,
            Self::PrintableNft,
            Self::ProgrammableNft,
            Self::Print,
            Self::TransferRestrictedNft,
            Self::NonTransferableNft,
            Self::IdentityNft,
            Self::MplCoreAsset,
            Self::MplCoreCollection,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::FungibleToken => Some("FungibleToken"),
                Self::FungibleAsset => Some("FungibleAsset"),
                Self::Nft => Some("Nft"),
                Self::PrintableNft => Some("PrintableNft"),
                Self::ProgrammableNft => Some("ProgrammableNft"),
                Self::Print => Some("Print"),
                Self::TransferRestrictedNft => Some("TransferRestrictedNft"),
                Self::NonTransferableNft => Some("NonTransferableNft"),
                Self::IdentityNft => Some("IdentityNft"),
                Self::MplCoreAsset => Some("MplCoreAsset"),
                Self::MplCoreCollection => Some("MplCoreCollection"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for SpecificationAssetClass {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SpecificationAssetClass {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for SpecificationAssetClass {
        type Output = SpecificationAssetClass;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for SpecificationAssetClass {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SpecificationAssetClass {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SpecificationAssetClass {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ROYALTY_TARGET_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ROYALTY_TARGET_TYPE: i8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ROYALTY_TARGET_TYPE: [RoyaltyTargetType; 4] = [
        RoyaltyTargetType::Unknown,
        RoyaltyTargetType::Creators,
        RoyaltyTargetType::Fanout,
        RoyaltyTargetType::Single,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct RoyaltyTargetType(pub i8);
    #[allow(non_upper_case_globals)]
    impl RoyaltyTargetType {
        pub const Unknown: Self = Self(0);
        pub const Creators: Self = Self(1);
        pub const Fanout: Self = Self(2);
        pub const Single: Self = Self(3);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 3;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::Unknown, Self::Creators, Self::Fanout, Self::Single];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::Creators => Some("Creators"),
                Self::Fanout => Some("Fanout"),
                Self::Single => Some("Single"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for RoyaltyTargetType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for RoyaltyTargetType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for RoyaltyTargetType {
        type Output = RoyaltyTargetType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for RoyaltyTargetType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for RoyaltyTargetType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for RoyaltyTargetType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_OWNER_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_OWNER_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_OWNER_TYPE: [OwnerType; 3] =
        [OwnerType::Unknown, OwnerType::Token, OwnerType::Single];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct OwnerType(pub i8);
    #[allow(non_upper_case_globals)]
    impl OwnerType {
        pub const Unknown: Self = Self(0);
        pub const Token: Self = Self(1);
        pub const Single: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Unknown, Self::Token, Self::Single];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Unknown => Some("Unknown"),
                Self::Token => Some("Token"),
                Self::Single => Some("Single"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for OwnerType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for OwnerType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for OwnerType {
        type Output = OwnerType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for OwnerType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for OwnerType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for OwnerType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CHAIN_MUTABILITY: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CHAIN_MUTABILITY: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CHAIN_MUTABILITY: [ChainMutability; 2] =
        [ChainMutability::Immutable, ChainMutability::Mutable];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ChainMutability(pub i8);
    #[allow(non_upper_case_globals)]
    impl ChainMutability {
        pub const Immutable: Self = Self(0);
        pub const Mutable: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Immutable, Self::Mutable];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Immutable => Some("Immutable"),
                Self::Mutable => Some("Mutable"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ChainMutability {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ChainMutability {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ChainMutability {
        type Output = ChainMutability;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ChainMutability {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ChainMutability {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ChainMutability {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_UPDATE_VERSION_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_UPDATE_VERSION_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_UPDATE_VERSION_TYPE: [UpdateVersionType; 3] =
        [UpdateVersionType::None, UpdateVersionType::Sequence, UpdateVersionType::WriteVersion];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct UpdateVersionType(pub i8);
    #[allow(non_upper_case_globals)]
    impl UpdateVersionType {
        pub const None: Self = Self(0);
        pub const Sequence: Self = Self(1);
        pub const WriteVersion: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::None, Self::Sequence, Self::WriteVersion];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::None => Some("None"),
                Self::Sequence => Some("Sequence"),
                Self::WriteVersion => Some("WriteVersion"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for UpdateVersionType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for UpdateVersionType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for UpdateVersionType {
        type Output = UpdateVersionType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for UpdateVersionType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for UpdateVersionType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for UpdateVersionType {}
    pub enum UpdateVersionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdateVersion<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdateVersion<'a> {
        type Inner = UpdateVersion<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdateVersion<'a> {
        pub const VT_VERSION_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_VERSION_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdateVersion { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdateVersionArgs,
        ) -> flatbuffers::WIPOffset<UpdateVersion<'bldr>> {
            let mut builder = UpdateVersionBuilder::new(_fbb);
            builder.add_version_value(args.version_value);
            builder.add_version_type(args.version_type);
            builder.finish()
        }

        #[inline]
        pub fn version_type(&self) -> UpdateVersionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<UpdateVersionType>(
                        UpdateVersion::VT_VERSION_TYPE,
                        Some(UpdateVersionType::None),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn version_value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdateVersion::VT_VERSION_VALUE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for UpdateVersion<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<UpdateVersionType>("version_type", Self::VT_VERSION_TYPE, false)?
                .visit_field::<u64>("version_value", Self::VT_VERSION_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdateVersionArgs {
        pub version_type: UpdateVersionType,
        pub version_value: u64,
    }
    impl<'a> Default for UpdateVersionArgs {
        #[inline]
        fn default() -> Self {
            UpdateVersionArgs { version_type: UpdateVersionType::None, version_value: 0 }
        }
    }

    pub struct UpdateVersionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdateVersionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_version_type(&mut self, version_type: UpdateVersionType) {
            self.fbb_.push_slot::<UpdateVersionType>(
                UpdateVersion::VT_VERSION_TYPE,
                version_type,
                UpdateVersionType::None,
            );
        }
        #[inline]
        pub fn add_version_value(&mut self, version_value: u64) {
            self.fbb_.push_slot::<u64>(UpdateVersion::VT_VERSION_VALUE, version_value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdateVersionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdateVersionBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdateVersion<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdateVersion<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdateVersion");
            ds.field("version_type", &self.version_type());
            ds.field("version_value", &self.version_value());
            ds.finish()
        }
    }
    pub enum UpdatedBoolOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedBool<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedBool<'a> {
        type Inner = UpdatedBool<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedBool<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedBool { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedBoolArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedBool<'bldr>> {
            let mut builder = UpdatedBoolBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.add_value(args.value);
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedBool::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedBool::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<bool>(UpdatedBool::VT_VALUE, Some(false)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for UpdatedBool<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<bool>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedBoolArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: bool,
    }
    impl<'a> Default for UpdatedBoolArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedBoolArgs { slot_updated: 0, update_version: None, value: false }
        }
    }

    pub struct UpdatedBoolBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedBoolBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedBool::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedBool::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: bool) {
            self.fbb_.push_slot::<bool>(UpdatedBool::VT_VALUE, value, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedBoolBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedBoolBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedBool<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedBool<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedBool");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedU64Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedU64<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedU64<'a> {
        type Inner = UpdatedU64<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedU64<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedU64 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedU64Args<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedU64<'bldr>> {
            let mut builder = UpdatedU64Builder::new(_fbb);
            builder.add_value(args.value);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedU64::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedU64::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedU64::VT_VALUE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for UpdatedU64<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedU64Args<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: u64,
    }
    impl<'a> Default for UpdatedU64Args<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedU64Args { slot_updated: 0, update_version: None, value: 0 }
        }
    }

    pub struct UpdatedU64Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedU64Builder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedU64::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedU64::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(UpdatedU64::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedU64Builder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedU64Builder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedU64<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedU64<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedU64");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedU32Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedU32<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedU32<'a> {
        type Inner = UpdatedU32<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedU32<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedU32 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedU32Args<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedU32<'bldr>> {
            let mut builder = UpdatedU32Builder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            builder.add_value(args.value);
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedU32::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedU32::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(UpdatedU32::VT_VALUE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for UpdatedU32<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<u32>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedU32Args<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: u32,
    }
    impl<'a> Default for UpdatedU32Args<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedU32Args { slot_updated: 0, update_version: None, value: 0 }
        }
    }

    pub struct UpdatedU32Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedU32Builder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedU32::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedU32::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: u32) {
            self.fbb_.push_slot::<u32>(UpdatedU32::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedU32Builder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedU32Builder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedU32<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedU32<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedU32");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedStringOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedString<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedString<'a> {
        type Inner = UpdatedString<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedString<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedString { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedStringArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedString<'bldr>> {
            let mut builder = UpdatedStringBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedString::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedString::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdatedString::VT_VALUE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UpdatedString<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedStringArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for UpdatedStringArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedStringArgs { slot_updated: 0, update_version: None, value: None }
        }
    }

    pub struct UpdatedStringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedStringBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedString::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedString::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdatedString::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedStringBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedStringBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedString<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedString<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedString");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedPubkeyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedPubkey<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedPubkey<'a> {
        type Inner = UpdatedPubkey<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedPubkey<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedPubkey { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedPubkeyArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedPubkey<'bldr>> {
            let mut builder = UpdatedPubkeyBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedPubkey::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedPubkey::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    UpdatedPubkey::VT_VALUE,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for UpdatedPubkey<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedPubkeyArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for UpdatedPubkeyArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedPubkeyArgs { slot_updated: 0, update_version: None, value: None }
        }
    }

    pub struct UpdatedPubkeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedPubkeyBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedPubkey::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedPubkey::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdatedPubkey::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedPubkeyBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedPubkeyBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedPubkey<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedPubkey<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedPubkey");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedOptionalPubkeyOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedOptionalPubkey<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedOptionalPubkey<'a> {
        type Inner = UpdatedOptionalPubkey<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedOptionalPubkey<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedOptionalPubkey { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedOptionalPubkeyArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedOptionalPubkey<'bldr>> {
            let mut builder = UpdatedOptionalPubkeyBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<u64>(UpdatedOptionalPubkey::VT_SLOT_UPDATED, Some(0)).unwrap()
            }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedOptionalPubkey::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    UpdatedOptionalPubkey::VT_VALUE,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for UpdatedOptionalPubkey<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "value",
                    Self::VT_VALUE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedOptionalPubkeyArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for UpdatedOptionalPubkeyArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedOptionalPubkeyArgs { slot_updated: 0, update_version: None, value: None }
        }
    }

    pub struct UpdatedOptionalPubkeyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedOptionalPubkeyBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedOptionalPubkey::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedOptionalPubkey::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UpdatedOptionalPubkey::VT_VALUE,
                value,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedOptionalPubkeyBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedOptionalPubkeyBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedOptionalPubkey<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedOptionalPubkey<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedOptionalPubkey");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedCreatorsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedCreators<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedCreators<'a> {
        type Inner = UpdatedCreators<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedCreators<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedCreators { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedCreatorsArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedCreators<'bldr>> {
            let mut builder = UpdatedCreatorsBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.value {
                builder.add_value(x);
            }
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedCreators::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedCreators::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Creator<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Creator>>,
                >>(UpdatedCreators::VT_VALUE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UpdatedCreators<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Creator>>,
                >>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedCreatorsArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Creator<'a>>>,
            >,
        >,
    }
    impl<'a> Default for UpdatedCreatorsArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedCreatorsArgs { slot_updated: 0, update_version: None, value: None }
        }
    }

    pub struct UpdatedCreatorsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedCreatorsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedCreators::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedCreators::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(
            &mut self,
            value: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Creator<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UpdatedCreators::VT_VALUE, value);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedCreatorsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedCreatorsBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedCreators<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedCreators<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedCreators");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedChainMutabilityOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedChainMutability<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedChainMutability<'a> {
        type Inner = UpdatedChainMutability<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedChainMutability<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedChainMutability { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedChainMutabilityArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedChainMutability<'bldr>> {
            let mut builder = UpdatedChainMutabilityBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.add_value(args.value);
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<u64>(UpdatedChainMutability::VT_SLOT_UPDATED, Some(0)).unwrap()
            }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedChainMutability::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> ChainMutability {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ChainMutability>(
                        UpdatedChainMutability::VT_VALUE,
                        Some(ChainMutability::Immutable),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdatedChainMutability<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<ChainMutability>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedChainMutabilityArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: ChainMutability,
    }
    impl<'a> Default for UpdatedChainMutabilityArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedChainMutabilityArgs {
                slot_updated: 0,
                update_version: None,
                value: ChainMutability::Immutable,
            }
        }
    }

    pub struct UpdatedChainMutabilityBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedChainMutabilityBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedChainMutability::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedChainMutability::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: ChainMutability) {
            self.fbb_.push_slot::<ChainMutability>(
                UpdatedChainMutability::VT_VALUE,
                value,
                ChainMutability::Immutable,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedChainMutabilityBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedChainMutabilityBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedChainMutability<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedChainMutability<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedChainMutability");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum UpdatedOwnerTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UpdatedOwnerType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UpdatedOwnerType<'a> {
        type Inner = UpdatedOwnerType<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> UpdatedOwnerType<'a> {
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 4;
        pub const VT_UPDATE_VERSION: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UpdatedOwnerType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UpdatedOwnerTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<UpdatedOwnerType<'bldr>> {
            let mut builder = UpdatedOwnerTypeBuilder::new(_fbb);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.update_version {
                builder.add_update_version(x);
            }
            builder.add_value(args.value);
            builder.finish()
        }

        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UpdatedOwnerType::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn update_version(&self) -> Option<UpdateVersion<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    UpdatedOwnerType::VT_UPDATE_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn value(&self) -> OwnerType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<OwnerType>(UpdatedOwnerType::VT_VALUE, Some(OwnerType::Unknown))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UpdatedOwnerType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdateVersion>>(
                    "update_version",
                    Self::VT_UPDATE_VERSION,
                    false,
                )?
                .visit_field::<OwnerType>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UpdatedOwnerTypeArgs<'a> {
        pub slot_updated: u64,
        pub update_version: Option<flatbuffers::WIPOffset<UpdateVersion<'a>>>,
        pub value: OwnerType,
    }
    impl<'a> Default for UpdatedOwnerTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            UpdatedOwnerTypeArgs {
                slot_updated: 0,
                update_version: None,
                value: OwnerType::Unknown,
            }
        }
    }

    pub struct UpdatedOwnerTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UpdatedOwnerTypeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(UpdatedOwnerType::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_update_version(
            &mut self,
            update_version: flatbuffers::WIPOffset<UpdateVersion<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdateVersion>>(
                UpdatedOwnerType::VT_UPDATE_VERSION,
                update_version,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: OwnerType) {
            self.fbb_.push_slot::<OwnerType>(UpdatedOwnerType::VT_VALUE, value, OwnerType::Unknown);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UpdatedOwnerTypeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UpdatedOwnerTypeBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UpdatedOwnerType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UpdatedOwnerType<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UpdatedOwnerType");
            ds.field("slot_updated", &self.slot_updated());
            ds.field("update_version", &self.update_version());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    pub enum CreatorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Creator<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Creator<'a> {
        type Inner = Creator<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> Creator<'a> {
        pub const VT_CREATOR: flatbuffers::VOffsetT = 4;
        pub const VT_CREATOR_VERIFIED: flatbuffers::VOffsetT = 6;
        pub const VT_CREATOR_SHARE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Creator { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args CreatorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Creator<'bldr>> {
            let mut builder = CreatorBuilder::new(_fbb);
            builder.add_creator_share(args.creator_share);
            if let Some(x) = args.creator {
                builder.add_creator(x);
            }
            builder.add_creator_verified(args.creator_verified);
            builder.finish()
        }

        #[inline]
        pub fn creator(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Creator::VT_CREATOR,
                    None,
                )
            }
        }
        #[inline]
        pub fn creator_verified(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<bool>(Creator::VT_CREATOR_VERIFIED, Some(false)).unwrap() }
        }
        #[inline]
        pub fn creator_share(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Creator::VT_CREATOR_SHARE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Creator<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "creator",
                    Self::VT_CREATOR,
                    false,
                )?
                .visit_field::<bool>("creator_verified", Self::VT_CREATOR_VERIFIED, false)?
                .visit_field::<u32>("creator_share", Self::VT_CREATOR_SHARE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CreatorArgs<'a> {
        pub creator: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub creator_verified: bool,
        pub creator_share: u32,
    }
    impl<'a> Default for CreatorArgs<'a> {
        #[inline]
        fn default() -> Self {
            CreatorArgs { creator: None, creator_verified: false, creator_share: 0 }
        }
    }

    pub struct CreatorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreatorBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_creator(
            &mut self,
            creator: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Creator::VT_CREATOR, creator);
        }
        #[inline]
        pub fn add_creator_verified(&mut self, creator_verified: bool) {
            self.fbb_.push_slot::<bool>(Creator::VT_CREATOR_VERIFIED, creator_verified, false);
        }
        #[inline]
        pub fn add_creator_share(&mut self, creator_share: u32) {
            self.fbb_.push_slot::<u32>(Creator::VT_CREATOR_SHARE, creator_share, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> CreatorBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            CreatorBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Creator<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Creator<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Creator");
            ds.field("creator", &self.creator());
            ds.field("creator_verified", &self.creator_verified());
            ds.field("creator_share", &self.creator_share());
            ds.finish()
        }
    }
    pub enum AssetStaticDetailsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssetStaticDetails<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssetStaticDetails<'a> {
        type Inner = AssetStaticDetails<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> AssetStaticDetails<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_SPECIFICATION_ASSET_CLASS: flatbuffers::VOffsetT = 6;
        pub const VT_ROYALTY_TARGET_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_CREATED_AT: flatbuffers::VOffsetT = 10;
        pub const VT_EDITION_ADDRESS: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssetStaticDetails { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AssetStaticDetailsArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssetStaticDetails<'bldr>> {
            let mut builder = AssetStaticDetailsBuilder::new(_fbb);
            builder.add_created_at(args.created_at);
            if let Some(x) = args.edition_address {
                builder.add_edition_address(x);
            }
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.add_royalty_target_type(args.royalty_target_type);
            builder.add_specification_asset_class(args.specification_asset_class);
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetStaticDetails::VT_PUBKEY,
                    None,
                )
            }
        }
        #[inline]
        pub fn specification_asset_class(&self) -> SpecificationAssetClass {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SpecificationAssetClass>(
                        AssetStaticDetails::VT_SPECIFICATION_ASSET_CLASS,
                        Some(SpecificationAssetClass::Unknown),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn royalty_target_type(&self) -> RoyaltyTargetType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<RoyaltyTargetType>(
                        AssetStaticDetails::VT_ROYALTY_TARGET_TYPE,
                        Some(RoyaltyTargetType::Unknown),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn created_at(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(AssetStaticDetails::VT_CREATED_AT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn edition_address(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetStaticDetails::VT_EDITION_ADDRESS,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for AssetStaticDetails<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<SpecificationAssetClass>(
                    "specification_asset_class",
                    Self::VT_SPECIFICATION_ASSET_CLASS,
                    false,
                )?
                .visit_field::<RoyaltyTargetType>(
                    "royalty_target_type",
                    Self::VT_ROYALTY_TARGET_TYPE,
                    false,
                )?
                .visit_field::<i64>("created_at", Self::VT_CREATED_AT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "edition_address",
                    Self::VT_EDITION_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AssetStaticDetailsArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub specification_asset_class: SpecificationAssetClass,
        pub royalty_target_type: RoyaltyTargetType,
        pub created_at: i64,
        pub edition_address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for AssetStaticDetailsArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssetStaticDetailsArgs {
                pubkey: None,
                specification_asset_class: SpecificationAssetClass::Unknown,
                royalty_target_type: RoyaltyTargetType::Unknown,
                created_at: 0,
                edition_address: None,
            }
        }
    }

    pub struct AssetStaticDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetStaticDetailsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssetStaticDetails::VT_PUBKEY,
                pubkey,
            );
        }
        #[inline]
        pub fn add_specification_asset_class(
            &mut self,
            specification_asset_class: SpecificationAssetClass,
        ) {
            self.fbb_.push_slot::<SpecificationAssetClass>(
                AssetStaticDetails::VT_SPECIFICATION_ASSET_CLASS,
                specification_asset_class,
                SpecificationAssetClass::Unknown,
            );
        }
        #[inline]
        pub fn add_royalty_target_type(&mut self, royalty_target_type: RoyaltyTargetType) {
            self.fbb_.push_slot::<RoyaltyTargetType>(
                AssetStaticDetails::VT_ROYALTY_TARGET_TYPE,
                royalty_target_type,
                RoyaltyTargetType::Unknown,
            );
        }
        #[inline]
        pub fn add_created_at(&mut self, created_at: i64) {
            self.fbb_.push_slot::<i64>(AssetStaticDetails::VT_CREATED_AT, created_at, 0);
        }
        #[inline]
        pub fn add_edition_address(
            &mut self,
            edition_address: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssetStaticDetails::VT_EDITION_ADDRESS,
                edition_address,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AssetStaticDetailsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AssetStaticDetailsBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssetStaticDetails<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssetStaticDetails<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssetStaticDetails");
            ds.field("pubkey", &self.pubkey());
            ds.field("specification_asset_class", &self.specification_asset_class());
            ds.field("royalty_target_type", &self.royalty_target_type());
            ds.field("created_at", &self.created_at());
            ds.field("edition_address", &self.edition_address());
            ds.finish()
        }
    }
    pub enum AssetDynamicDetailsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssetDynamicDetails<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssetDynamicDetails<'a> {
        type Inner = AssetDynamicDetails<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> AssetDynamicDetails<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_IS_COMPRESSIBLE: flatbuffers::VOffsetT = 6;
        pub const VT_IS_COMPRESSED: flatbuffers::VOffsetT = 8;
        pub const VT_IS_FROZEN: flatbuffers::VOffsetT = 10;
        pub const VT_SUPPLY: flatbuffers::VOffsetT = 12;
        pub const VT_SEQ: flatbuffers::VOffsetT = 14;
        pub const VT_IS_BURNT: flatbuffers::VOffsetT = 16;
        pub const VT_WAS_DECOMPRESSED: flatbuffers::VOffsetT = 18;
        pub const VT_ONCHAIN_DATA: flatbuffers::VOffsetT = 20;
        pub const VT_CREATORS: flatbuffers::VOffsetT = 22;
        pub const VT_ROYALTY_AMOUNT: flatbuffers::VOffsetT = 24;
        pub const VT_URL: flatbuffers::VOffsetT = 26;
        pub const VT_CHAIN_MUTABILITY: flatbuffers::VOffsetT = 28;
        pub const VT_LAMPORTS: flatbuffers::VOffsetT = 30;
        pub const VT_EXECUTABLE: flatbuffers::VOffsetT = 32;
        pub const VT_METADATA_OWNER: flatbuffers::VOffsetT = 34;
        pub const VT_RAW_NAME: flatbuffers::VOffsetT = 36;
        pub const VT_MPL_CORE_PLUGINS: flatbuffers::VOffsetT = 38;
        pub const VT_MPL_CORE_UNKNOWN_PLUGINS: flatbuffers::VOffsetT = 40;
        pub const VT_RENT_EPOCH: flatbuffers::VOffsetT = 42;
        pub const VT_NUM_MINTED: flatbuffers::VOffsetT = 44;
        pub const VT_CURRENT_SIZE: flatbuffers::VOffsetT = 46;
        pub const VT_PLUGINS_JSON_VERSION: flatbuffers::VOffsetT = 48;
        pub const VT_MPL_CORE_EXTERNAL_PLUGINS: flatbuffers::VOffsetT = 50;
        pub const VT_MPL_CORE_UNKNOWN_EXTERNAL_PLUGINS: flatbuffers::VOffsetT = 52;
        pub const VT_MINT_EXTENSIONS: flatbuffers::VOffsetT = 54;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssetDynamicDetails { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AssetDynamicDetailsArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssetDynamicDetails<'bldr>> {
            let mut builder = AssetDynamicDetailsBuilder::new(_fbb);
            if let Some(x) = args.mint_extensions {
                builder.add_mint_extensions(x);
            }
            if let Some(x) = args.mpl_core_unknown_external_plugins {
                builder.add_mpl_core_unknown_external_plugins(x);
            }
            if let Some(x) = args.mpl_core_external_plugins {
                builder.add_mpl_core_external_plugins(x);
            }
            if let Some(x) = args.plugins_json_version {
                builder.add_plugins_json_version(x);
            }
            if let Some(x) = args.current_size {
                builder.add_current_size(x);
            }
            if let Some(x) = args.num_minted {
                builder.add_num_minted(x);
            }
            if let Some(x) = args.rent_epoch {
                builder.add_rent_epoch(x);
            }
            if let Some(x) = args.mpl_core_unknown_plugins {
                builder.add_mpl_core_unknown_plugins(x);
            }
            if let Some(x) = args.mpl_core_plugins {
                builder.add_mpl_core_plugins(x);
            }
            if let Some(x) = args.raw_name {
                builder.add_raw_name(x);
            }
            if let Some(x) = args.metadata_owner {
                builder.add_metadata_owner(x);
            }
            if let Some(x) = args.executable {
                builder.add_executable(x);
            }
            if let Some(x) = args.lamports {
                builder.add_lamports(x);
            }
            if let Some(x) = args.chain_mutability {
                builder.add_chain_mutability(x);
            }
            if let Some(x) = args.url {
                builder.add_url(x);
            }
            if let Some(x) = args.royalty_amount {
                builder.add_royalty_amount(x);
            }
            if let Some(x) = args.creators {
                builder.add_creators(x);
            }
            if let Some(x) = args.onchain_data {
                builder.add_onchain_data(x);
            }
            if let Some(x) = args.was_decompressed {
                builder.add_was_decompressed(x);
            }
            if let Some(x) = args.is_burnt {
                builder.add_is_burnt(x);
            }
            if let Some(x) = args.seq {
                builder.add_seq(x);
            }
            if let Some(x) = args.supply {
                builder.add_supply(x);
            }
            if let Some(x) = args.is_frozen {
                builder.add_is_frozen(x);
            }
            if let Some(x) = args.is_compressed {
                builder.add_is_compressed(x);
            }
            if let Some(x) = args.is_compressible {
                builder.add_is_compressible(x);
            }
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetDynamicDetails::VT_PUBKEY,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_compressible(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetDynamicDetails::VT_IS_COMPRESSIBLE,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_compressed(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetDynamicDetails::VT_IS_COMPRESSED,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_frozen(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetDynamicDetails::VT_IS_FROZEN,
                    None,
                )
            }
        }
        #[inline]
        pub fn supply(&self) -> Option<UpdatedU64<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    AssetDynamicDetails::VT_SUPPLY,
                    None,
                )
            }
        }
        #[inline]
        pub fn seq(&self) -> Option<UpdatedU64<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    AssetDynamicDetails::VT_SEQ,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_burnt(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetDynamicDetails::VT_IS_BURNT,
                    None,
                )
            }
        }
        #[inline]
        pub fn was_decompressed(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetDynamicDetails::VT_WAS_DECOMPRESSED,
                    None,
                )
            }
        }
        #[inline]
        pub fn onchain_data(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_ONCHAIN_DATA,
                    None,
                )
            }
        }
        #[inline]
        pub fn creators(&self) -> Option<UpdatedCreators<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedCreators>>(
                    AssetDynamicDetails::VT_CREATORS,
                    None,
                )
            }
        }
        #[inline]
        pub fn royalty_amount(&self) -> Option<UpdatedU32<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    AssetDynamicDetails::VT_ROYALTY_AMOUNT,
                    None,
                )
            }
        }
        #[inline]
        pub fn url(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_URL,
                    None,
                )
            }
        }
        #[inline]
        pub fn chain_mutability(&self) -> Option<UpdatedChainMutability<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedChainMutability>>(
                    AssetDynamicDetails::VT_CHAIN_MUTABILITY,
                    None,
                )
            }
        }
        #[inline]
        pub fn lamports(&self) -> Option<UpdatedU64<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    AssetDynamicDetails::VT_LAMPORTS,
                    None,
                )
            }
        }
        #[inline]
        pub fn executable(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetDynamicDetails::VT_EXECUTABLE,
                    None,
                )
            }
        }
        #[inline]
        pub fn metadata_owner(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_METADATA_OWNER,
                    None,
                )
            }
        }
        #[inline]
        pub fn raw_name(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_RAW_NAME,
                    None,
                )
            }
        }
        #[inline]
        pub fn mpl_core_plugins(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_MPL_CORE_PLUGINS,
                    None,
                )
            }
        }
        #[inline]
        pub fn mpl_core_unknown_plugins(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_MPL_CORE_UNKNOWN_PLUGINS,
                    None,
                )
            }
        }
        #[inline]
        pub fn rent_epoch(&self) -> Option<UpdatedU64<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    AssetDynamicDetails::VT_RENT_EPOCH,
                    None,
                )
            }
        }
        #[inline]
        pub fn num_minted(&self) -> Option<UpdatedU32<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    AssetDynamicDetails::VT_NUM_MINTED,
                    None,
                )
            }
        }
        #[inline]
        pub fn current_size(&self) -> Option<UpdatedU32<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    AssetDynamicDetails::VT_CURRENT_SIZE,
                    None,
                )
            }
        }
        #[inline]
        pub fn plugins_json_version(&self) -> Option<UpdatedU32<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    AssetDynamicDetails::VT_PLUGINS_JSON_VERSION,
                    None,
                )
            }
        }
        #[inline]
        pub fn mpl_core_external_plugins(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_MPL_CORE_EXTERNAL_PLUGINS,
                    None,
                )
            }
        }
        #[inline]
        pub fn mpl_core_unknown_external_plugins(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_MPL_CORE_UNKNOWN_EXTERNAL_PLUGINS,
                    None,
                )
            }
        }
        #[inline]
        pub fn mint_extensions(&self) -> Option<UpdatedString<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    AssetDynamicDetails::VT_MINT_EXTENSIONS,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for AssetDynamicDetails<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "is_compressible",
                    Self::VT_IS_COMPRESSIBLE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "is_compressed",
                    Self::VT_IS_COMPRESSED,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "is_frozen",
                    Self::VT_IS_FROZEN,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    "supply",
                    Self::VT_SUPPLY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    "seq",
                    Self::VT_SEQ,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "is_burnt",
                    Self::VT_IS_BURNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "was_decompressed",
                    Self::VT_WAS_DECOMPRESSED,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "onchain_data",
                    Self::VT_ONCHAIN_DATA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedCreators>>(
                    "creators",
                    Self::VT_CREATORS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    "royalty_amount",
                    Self::VT_ROYALTY_AMOUNT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "url",
                    Self::VT_URL,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedChainMutability>>(
                    "chain_mutability",
                    Self::VT_CHAIN_MUTABILITY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    "lamports",
                    Self::VT_LAMPORTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "executable",
                    Self::VT_EXECUTABLE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "metadata_owner",
                    Self::VT_METADATA_OWNER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "raw_name",
                    Self::VT_RAW_NAME,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "mpl_core_plugins",
                    Self::VT_MPL_CORE_PLUGINS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "mpl_core_unknown_plugins",
                    Self::VT_MPL_CORE_UNKNOWN_PLUGINS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    "rent_epoch",
                    Self::VT_RENT_EPOCH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    "num_minted",
                    Self::VT_NUM_MINTED,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    "current_size",
                    Self::VT_CURRENT_SIZE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU32>>(
                    "plugins_json_version",
                    Self::VT_PLUGINS_JSON_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "mpl_core_external_plugins",
                    Self::VT_MPL_CORE_EXTERNAL_PLUGINS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "mpl_core_unknown_external_plugins",
                    Self::VT_MPL_CORE_UNKNOWN_EXTERNAL_PLUGINS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedString>>(
                    "mint_extensions",
                    Self::VT_MINT_EXTENSIONS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AssetDynamicDetailsArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub is_compressible: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub is_compressed: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub is_frozen: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub supply: Option<flatbuffers::WIPOffset<UpdatedU64<'a>>>,
        pub seq: Option<flatbuffers::WIPOffset<UpdatedU64<'a>>>,
        pub is_burnt: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub was_decompressed: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub onchain_data: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub creators: Option<flatbuffers::WIPOffset<UpdatedCreators<'a>>>,
        pub royalty_amount: Option<flatbuffers::WIPOffset<UpdatedU32<'a>>>,
        pub url: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub chain_mutability: Option<flatbuffers::WIPOffset<UpdatedChainMutability<'a>>>,
        pub lamports: Option<flatbuffers::WIPOffset<UpdatedU64<'a>>>,
        pub executable: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub metadata_owner: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub raw_name: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub mpl_core_plugins: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub mpl_core_unknown_plugins: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub rent_epoch: Option<flatbuffers::WIPOffset<UpdatedU64<'a>>>,
        pub num_minted: Option<flatbuffers::WIPOffset<UpdatedU32<'a>>>,
        pub current_size: Option<flatbuffers::WIPOffset<UpdatedU32<'a>>>,
        pub plugins_json_version: Option<flatbuffers::WIPOffset<UpdatedU32<'a>>>,
        pub mpl_core_external_plugins: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub mpl_core_unknown_external_plugins: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
        pub mint_extensions: Option<flatbuffers::WIPOffset<UpdatedString<'a>>>,
    }
    impl<'a> Default for AssetDynamicDetailsArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssetDynamicDetailsArgs {
                pubkey: None,
                is_compressible: None,
                is_compressed: None,
                is_frozen: None,
                supply: None,
                seq: None,
                is_burnt: None,
                was_decompressed: None,
                onchain_data: None,
                creators: None,
                royalty_amount: None,
                url: None,
                chain_mutability: None,
                lamports: None,
                executable: None,
                metadata_owner: None,
                raw_name: None,
                mpl_core_plugins: None,
                mpl_core_unknown_plugins: None,
                rent_epoch: None,
                num_minted: None,
                current_size: None,
                plugins_json_version: None,
                mpl_core_external_plugins: None,
                mpl_core_unknown_external_plugins: None,
                mint_extensions: None,
            }
        }
    }

    pub struct AssetDynamicDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetDynamicDetailsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssetDynamicDetails::VT_PUBKEY,
                pubkey,
            );
        }
        #[inline]
        pub fn add_is_compressible(
            &mut self,
            is_compressible: flatbuffers::WIPOffset<UpdatedBool<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetDynamicDetails::VT_IS_COMPRESSIBLE,
                is_compressible,
            );
        }
        #[inline]
        pub fn add_is_compressed(
            &mut self,
            is_compressed: flatbuffers::WIPOffset<UpdatedBool<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetDynamicDetails::VT_IS_COMPRESSED,
                is_compressed,
            );
        }
        #[inline]
        pub fn add_is_frozen(&mut self, is_frozen: flatbuffers::WIPOffset<UpdatedBool<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetDynamicDetails::VT_IS_FROZEN,
                is_frozen,
            );
        }
        #[inline]
        pub fn add_supply(&mut self, supply: flatbuffers::WIPOffset<UpdatedU64<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU64>>(
                AssetDynamicDetails::VT_SUPPLY,
                supply,
            );
        }
        #[inline]
        pub fn add_seq(&mut self, seq: flatbuffers::WIPOffset<UpdatedU64<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU64>>(
                AssetDynamicDetails::VT_SEQ,
                seq,
            );
        }
        #[inline]
        pub fn add_is_burnt(&mut self, is_burnt: flatbuffers::WIPOffset<UpdatedBool<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetDynamicDetails::VT_IS_BURNT,
                is_burnt,
            );
        }
        #[inline]
        pub fn add_was_decompressed(
            &mut self,
            was_decompressed: flatbuffers::WIPOffset<UpdatedBool<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetDynamicDetails::VT_WAS_DECOMPRESSED,
                was_decompressed,
            );
        }
        #[inline]
        pub fn add_onchain_data(
            &mut self,
            onchain_data: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_ONCHAIN_DATA,
                onchain_data,
            );
        }
        #[inline]
        pub fn add_creators(&mut self, creators: flatbuffers::WIPOffset<UpdatedCreators<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedCreators>>(
                AssetDynamicDetails::VT_CREATORS,
                creators,
            );
        }
        #[inline]
        pub fn add_royalty_amount(
            &mut self,
            royalty_amount: flatbuffers::WIPOffset<UpdatedU32<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU32>>(
                AssetDynamicDetails::VT_ROYALTY_AMOUNT,
                royalty_amount,
            );
        }
        #[inline]
        pub fn add_url(&mut self, url: flatbuffers::WIPOffset<UpdatedString<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_URL,
                url,
            );
        }
        #[inline]
        pub fn add_chain_mutability(
            &mut self,
            chain_mutability: flatbuffers::WIPOffset<UpdatedChainMutability<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedChainMutability>>(
                AssetDynamicDetails::VT_CHAIN_MUTABILITY,
                chain_mutability,
            );
        }
        #[inline]
        pub fn add_lamports(&mut self, lamports: flatbuffers::WIPOffset<UpdatedU64<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU64>>(
                AssetDynamicDetails::VT_LAMPORTS,
                lamports,
            );
        }
        #[inline]
        pub fn add_executable(&mut self, executable: flatbuffers::WIPOffset<UpdatedBool<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetDynamicDetails::VT_EXECUTABLE,
                executable,
            );
        }
        #[inline]
        pub fn add_metadata_owner(
            &mut self,
            metadata_owner: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_METADATA_OWNER,
                metadata_owner,
            );
        }
        #[inline]
        pub fn add_raw_name(&mut self, raw_name: flatbuffers::WIPOffset<UpdatedString<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_RAW_NAME,
                raw_name,
            );
        }
        #[inline]
        pub fn add_mpl_core_plugins(
            &mut self,
            mpl_core_plugins: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_MPL_CORE_PLUGINS,
                mpl_core_plugins,
            );
        }
        #[inline]
        pub fn add_mpl_core_unknown_plugins(
            &mut self,
            mpl_core_unknown_plugins: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_MPL_CORE_UNKNOWN_PLUGINS,
                mpl_core_unknown_plugins,
            );
        }
        #[inline]
        pub fn add_rent_epoch(&mut self, rent_epoch: flatbuffers::WIPOffset<UpdatedU64<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU64>>(
                AssetDynamicDetails::VT_RENT_EPOCH,
                rent_epoch,
            );
        }
        #[inline]
        pub fn add_num_minted(&mut self, num_minted: flatbuffers::WIPOffset<UpdatedU32<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU32>>(
                AssetDynamicDetails::VT_NUM_MINTED,
                num_minted,
            );
        }
        #[inline]
        pub fn add_current_size(&mut self, current_size: flatbuffers::WIPOffset<UpdatedU32<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU32>>(
                AssetDynamicDetails::VT_CURRENT_SIZE,
                current_size,
            );
        }
        #[inline]
        pub fn add_plugins_json_version(
            &mut self,
            plugins_json_version: flatbuffers::WIPOffset<UpdatedU32<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU32>>(
                AssetDynamicDetails::VT_PLUGINS_JSON_VERSION,
                plugins_json_version,
            );
        }
        #[inline]
        pub fn add_mpl_core_external_plugins(
            &mut self,
            mpl_core_external_plugins: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_MPL_CORE_EXTERNAL_PLUGINS,
                mpl_core_external_plugins,
            );
        }
        #[inline]
        pub fn add_mpl_core_unknown_external_plugins(
            &mut self,
            mpl_core_unknown_external_plugins: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_MPL_CORE_UNKNOWN_EXTERNAL_PLUGINS,
                mpl_core_unknown_external_plugins,
            );
        }
        #[inline]
        pub fn add_mint_extensions(
            &mut self,
            mint_extensions: flatbuffers::WIPOffset<UpdatedString<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedString>>(
                AssetDynamicDetails::VT_MINT_EXTENSIONS,
                mint_extensions,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AssetDynamicDetailsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AssetDynamicDetailsBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssetDynamicDetails<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssetDynamicDetails<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssetDynamicDetails");
            ds.field("pubkey", &self.pubkey());
            ds.field("is_compressible", &self.is_compressible());
            ds.field("is_compressed", &self.is_compressed());
            ds.field("is_frozen", &self.is_frozen());
            ds.field("supply", &self.supply());
            ds.field("seq", &self.seq());
            ds.field("is_burnt", &self.is_burnt());
            ds.field("was_decompressed", &self.was_decompressed());
            ds.field("onchain_data", &self.onchain_data());
            ds.field("creators", &self.creators());
            ds.field("royalty_amount", &self.royalty_amount());
            ds.field("url", &self.url());
            ds.field("chain_mutability", &self.chain_mutability());
            ds.field("lamports", &self.lamports());
            ds.field("executable", &self.executable());
            ds.field("metadata_owner", &self.metadata_owner());
            ds.field("raw_name", &self.raw_name());
            ds.field("mpl_core_plugins", &self.mpl_core_plugins());
            ds.field("mpl_core_unknown_plugins", &self.mpl_core_unknown_plugins());
            ds.field("rent_epoch", &self.rent_epoch());
            ds.field("num_minted", &self.num_minted());
            ds.field("current_size", &self.current_size());
            ds.field("plugins_json_version", &self.plugins_json_version());
            ds.field("mpl_core_external_plugins", &self.mpl_core_external_plugins());
            ds.field(
                "mpl_core_unknown_external_plugins",
                &self.mpl_core_unknown_external_plugins(),
            );
            ds.field("mint_extensions", &self.mint_extensions());
            ds.finish()
        }
    }
    pub enum AssetAuthorityOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssetAuthority<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssetAuthority<'a> {
        type Inner = AssetAuthority<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> AssetAuthority<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_AUTHORITY: flatbuffers::VOffsetT = 6;
        pub const VT_SLOT_UPDATED: flatbuffers::VOffsetT = 8;
        pub const VT_WRITE_VERSION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssetAuthority { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AssetAuthorityArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssetAuthority<'bldr>> {
            let mut builder = AssetAuthorityBuilder::new(_fbb);
            builder.add_write_version(args.write_version);
            builder.add_slot_updated(args.slot_updated);
            if let Some(x) = args.authority {
                builder.add_authority(x);
            }
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetAuthority::VT_PUBKEY,
                    None,
                )
            }
        }
        #[inline]
        pub fn authority(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetAuthority::VT_AUTHORITY,
                    None,
                )
            }
        }
        #[inline]
        pub fn slot_updated(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(AssetAuthority::VT_SLOT_UPDATED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn write_version(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(AssetAuthority::VT_WRITE_VERSION, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for AssetAuthority<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "authority",
                    Self::VT_AUTHORITY,
                    false,
                )?
                .visit_field::<u64>("slot_updated", Self::VT_SLOT_UPDATED, false)?
                .visit_field::<u64>("write_version", Self::VT_WRITE_VERSION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AssetAuthorityArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub authority: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub slot_updated: u64,
        pub write_version: u64,
    }
    impl<'a> Default for AssetAuthorityArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssetAuthorityArgs { pubkey: None, authority: None, slot_updated: 0, write_version: 0 }
        }
    }

    pub struct AssetAuthorityBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetAuthorityBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AssetAuthority::VT_PUBKEY, pubkey);
        }
        #[inline]
        pub fn add_authority(
            &mut self,
            authority: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssetAuthority::VT_AUTHORITY,
                authority,
            );
        }
        #[inline]
        pub fn add_slot_updated(&mut self, slot_updated: u64) {
            self.fbb_.push_slot::<u64>(AssetAuthority::VT_SLOT_UPDATED, slot_updated, 0);
        }
        #[inline]
        pub fn add_write_version(&mut self, write_version: u64) {
            self.fbb_.push_slot::<u64>(AssetAuthority::VT_WRITE_VERSION, write_version, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AssetAuthorityBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AssetAuthorityBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssetAuthority<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssetAuthority<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssetAuthority");
            ds.field("pubkey", &self.pubkey());
            ds.field("authority", &self.authority());
            ds.field("slot_updated", &self.slot_updated());
            ds.field("write_version", &self.write_version());
            ds.finish()
        }
    }
    pub enum AssetOwnerOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssetOwner<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssetOwner<'a> {
        type Inner = AssetOwner<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> AssetOwner<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_OWNER: flatbuffers::VOffsetT = 6;
        pub const VT_DELEGATE: flatbuffers::VOffsetT = 8;
        pub const VT_OWNER_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_OWNER_DELEGATE_SEQ: flatbuffers::VOffsetT = 12;
        pub const VT_IS_CURRENT_OWNER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssetOwner { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AssetOwnerArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssetOwner<'bldr>> {
            let mut builder = AssetOwnerBuilder::new(_fbb);
            if let Some(x) = args.is_current_owner {
                builder.add_is_current_owner(x);
            }
            if let Some(x) = args.owner_delegate_seq {
                builder.add_owner_delegate_seq(x);
            }
            if let Some(x) = args.owner_type {
                builder.add_owner_type(x);
            }
            if let Some(x) = args.delegate {
                builder.add_delegate(x);
            }
            if let Some(x) = args.owner {
                builder.add_owner(x);
            }
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetOwner::VT_PUBKEY,
                    None,
                )
            }
        }
        #[inline]
        pub fn owner(&self) -> Option<UpdatedOptionalPubkey<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedOptionalPubkey>>(
                    AssetOwner::VT_OWNER,
                    None,
                )
            }
        }
        #[inline]
        pub fn delegate(&self) -> Option<UpdatedOptionalPubkey<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedOptionalPubkey>>(
                    AssetOwner::VT_DELEGATE,
                    None,
                )
            }
        }
        #[inline]
        pub fn owner_type(&self) -> Option<UpdatedOwnerType<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedOwnerType>>(
                    AssetOwner::VT_OWNER_TYPE,
                    None,
                )
            }
        }
        #[inline]
        pub fn owner_delegate_seq(&self) -> Option<UpdatedU64<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    AssetOwner::VT_OWNER_DELEGATE_SEQ,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_current_owner(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetOwner::VT_IS_CURRENT_OWNER,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for AssetOwner<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedOptionalPubkey>>(
                    "owner",
                    Self::VT_OWNER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedOptionalPubkey>>(
                    "delegate",
                    Self::VT_DELEGATE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedOwnerType>>(
                    "owner_type",
                    Self::VT_OWNER_TYPE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedU64>>(
                    "owner_delegate_seq",
                    Self::VT_OWNER_DELEGATE_SEQ,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "is_current_owner",
                    Self::VT_IS_CURRENT_OWNER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AssetOwnerArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub owner: Option<flatbuffers::WIPOffset<UpdatedOptionalPubkey<'a>>>,
        pub delegate: Option<flatbuffers::WIPOffset<UpdatedOptionalPubkey<'a>>>,
        pub owner_type: Option<flatbuffers::WIPOffset<UpdatedOwnerType<'a>>>,
        pub owner_delegate_seq: Option<flatbuffers::WIPOffset<UpdatedU64<'a>>>,
        pub is_current_owner: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
    }
    impl<'a> Default for AssetOwnerArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssetOwnerArgs {
                pubkey: None,
                owner: None,
                delegate: None,
                owner_type: None,
                owner_delegate_seq: None,
                is_current_owner: None,
            }
        }
    }

    pub struct AssetOwnerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetOwnerBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AssetOwner::VT_PUBKEY, pubkey);
        }
        #[inline]
        pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<UpdatedOptionalPubkey<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedOptionalPubkey>>(
                AssetOwner::VT_OWNER,
                owner,
            );
        }
        #[inline]
        pub fn add_delegate(
            &mut self,
            delegate: flatbuffers::WIPOffset<UpdatedOptionalPubkey<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedOptionalPubkey>>(
                AssetOwner::VT_DELEGATE,
                delegate,
            );
        }
        #[inline]
        pub fn add_owner_type(&mut self, owner_type: flatbuffers::WIPOffset<UpdatedOwnerType<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedOwnerType>>(
                AssetOwner::VT_OWNER_TYPE,
                owner_type,
            );
        }
        #[inline]
        pub fn add_owner_delegate_seq(
            &mut self,
            owner_delegate_seq: flatbuffers::WIPOffset<UpdatedU64<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedU64>>(
                AssetOwner::VT_OWNER_DELEGATE_SEQ,
                owner_delegate_seq,
            );
        }
        #[inline]
        pub fn add_is_current_owner(
            &mut self,
            is_current_owner: flatbuffers::WIPOffset<UpdatedBool<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetOwner::VT_IS_CURRENT_OWNER,
                is_current_owner,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AssetOwnerBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AssetOwnerBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssetOwner<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssetOwner<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssetOwner");
            ds.field("pubkey", &self.pubkey());
            ds.field("owner", &self.owner());
            ds.field("delegate", &self.delegate());
            ds.field("owner_type", &self.owner_type());
            ds.field("owner_delegate_seq", &self.owner_delegate_seq());
            ds.field("is_current_owner", &self.is_current_owner());
            ds.finish()
        }
    }
    pub enum AssetCollectionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssetCollection<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssetCollection<'a> {
        type Inner = AssetCollection<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> AssetCollection<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_COLLECTION: flatbuffers::VOffsetT = 6;
        pub const VT_IS_COLLECTION_VERIFIED: flatbuffers::VOffsetT = 8;
        pub const VT_AUTHORITY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssetCollection { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AssetCollectionArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssetCollection<'bldr>> {
            let mut builder = AssetCollectionBuilder::new(_fbb);
            if let Some(x) = args.authority {
                builder.add_authority(x);
            }
            if let Some(x) = args.is_collection_verified {
                builder.add_is_collection_verified(x);
            }
            if let Some(x) = args.collection {
                builder.add_collection(x);
            }
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetCollection::VT_PUBKEY,
                    None,
                )
            }
        }
        #[inline]
        pub fn collection(&self) -> Option<UpdatedPubkey<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedPubkey>>(
                    AssetCollection::VT_COLLECTION,
                    None,
                )
            }
        }
        #[inline]
        pub fn is_collection_verified(&self) -> Option<UpdatedBool<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    AssetCollection::VT_IS_COLLECTION_VERIFIED,
                    None,
                )
            }
        }
        #[inline]
        pub fn authority(&self) -> Option<UpdatedOptionalPubkey<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<UpdatedOptionalPubkey>>(
                    AssetCollection::VT_AUTHORITY,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for AssetCollection<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedPubkey>>(
                    "collection",
                    Self::VT_COLLECTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedBool>>(
                    "is_collection_verified",
                    Self::VT_IS_COLLECTION_VERIFIED,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<UpdatedOptionalPubkey>>(
                    "authority",
                    Self::VT_AUTHORITY,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AssetCollectionArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub collection: Option<flatbuffers::WIPOffset<UpdatedPubkey<'a>>>,
        pub is_collection_verified: Option<flatbuffers::WIPOffset<UpdatedBool<'a>>>,
        pub authority: Option<flatbuffers::WIPOffset<UpdatedOptionalPubkey<'a>>>,
    }
    impl<'a> Default for AssetCollectionArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssetCollectionArgs {
                pubkey: None,
                collection: None,
                is_collection_verified: None,
                authority: None,
            }
        }
    }

    pub struct AssetCollectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetCollectionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AssetCollection::VT_PUBKEY, pubkey);
        }
        #[inline]
        pub fn add_collection(&mut self, collection: flatbuffers::WIPOffset<UpdatedPubkey<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedPubkey>>(
                AssetCollection::VT_COLLECTION,
                collection,
            );
        }
        #[inline]
        pub fn add_is_collection_verified(
            &mut self,
            is_collection_verified: flatbuffers::WIPOffset<UpdatedBool<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedBool>>(
                AssetCollection::VT_IS_COLLECTION_VERIFIED,
                is_collection_verified,
            );
        }
        #[inline]
        pub fn add_authority(
            &mut self,
            authority: flatbuffers::WIPOffset<UpdatedOptionalPubkey<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UpdatedOptionalPubkey>>(
                AssetCollection::VT_AUTHORITY,
                authority,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AssetCollectionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AssetCollectionBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssetCollection<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssetCollection<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssetCollection");
            ds.field("pubkey", &self.pubkey());
            ds.field("collection", &self.collection());
            ds.field("is_collection_verified", &self.is_collection_verified());
            ds.field("authority", &self.authority());
            ds.finish()
        }
    }
    pub enum AssetCompleteDetailsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssetCompleteDetails<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssetCompleteDetails<'a> {
        type Inner = AssetCompleteDetails<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self { _tab: flatbuffers::Table::new(buf, loc) }
        }
    }

    impl<'a> AssetCompleteDetails<'a> {
        pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_STATIC_DETAILS: flatbuffers::VOffsetT = 6;
        pub const VT_DYNAMIC_DETAILS: flatbuffers::VOffsetT = 8;
        pub const VT_AUTHORITY: flatbuffers::VOffsetT = 10;
        pub const VT_OWNER: flatbuffers::VOffsetT = 12;
        pub const VT_COLLECTION: flatbuffers::VOffsetT = 14;
        pub const VT_OTHER_KNOWN_OWNERS: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssetCompleteDetails { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args AssetCompleteDetailsArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssetCompleteDetails<'bldr>> {
            let mut builder = AssetCompleteDetailsBuilder::new(_fbb);
            if let Some(x) = args.other_known_owners {
                builder.add_other_known_owners(x);
            }
            if let Some(x) = args.collection {
                builder.add_collection(x);
            }
            if let Some(x) = args.owner {
                builder.add_owner(x);
            }
            if let Some(x) = args.authority {
                builder.add_authority(x);
            }
            if let Some(x) = args.dynamic_details {
                builder.add_dynamic_details(x);
            }
            if let Some(x) = args.static_details {
                builder.add_static_details(x);
            }
            if let Some(x) = args.pubkey {
                builder.add_pubkey(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn pubkey(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AssetCompleteDetails::VT_PUBKEY,
                    None,
                )
            }
        }
        #[inline]
        pub fn static_details(&self) -> Option<AssetStaticDetails<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<AssetStaticDetails>>(
                    AssetCompleteDetails::VT_STATIC_DETAILS,
                    None,
                )
            }
        }
        #[inline]
        pub fn dynamic_details(&self) -> Option<AssetDynamicDetails<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<AssetDynamicDetails>>(
                    AssetCompleteDetails::VT_DYNAMIC_DETAILS,
                    None,
                )
            }
        }
        #[inline]
        pub fn authority(&self) -> Option<AssetAuthority<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<AssetAuthority>>(
                    AssetCompleteDetails::VT_AUTHORITY,
                    None,
                )
            }
        }
        #[inline]
        pub fn owner(&self) -> Option<AssetOwner<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<AssetOwner>>(
                    AssetCompleteDetails::VT_OWNER,
                    None,
                )
            }
        }
        #[inline]
        pub fn collection(&self) -> Option<AssetCollection<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<AssetCollection>>(
                    AssetCompleteDetails::VT_COLLECTION,
                    None,
                )
            }
        }
        #[inline]
        pub fn other_known_owners(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssetOwner<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssetOwner>>,
                >>(AssetCompleteDetails::VT_OTHER_KNOWN_OWNERS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AssetCompleteDetails<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "pubkey",
                    Self::VT_PUBKEY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<AssetStaticDetails>>(
                    "static_details",
                    Self::VT_STATIC_DETAILS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<AssetDynamicDetails>>(
                    "dynamic_details",
                    Self::VT_DYNAMIC_DETAILS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<AssetAuthority>>(
                    "authority",
                    Self::VT_AUTHORITY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<AssetOwner>>(
                    "owner",
                    Self::VT_OWNER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<AssetCollection>>(
                    "collection",
                    Self::VT_COLLECTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssetOwner>>,
                >>("other_known_owners", Self::VT_OTHER_KNOWN_OWNERS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AssetCompleteDetailsArgs<'a> {
        pub pubkey: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub static_details: Option<flatbuffers::WIPOffset<AssetStaticDetails<'a>>>,
        pub dynamic_details: Option<flatbuffers::WIPOffset<AssetDynamicDetails<'a>>>,
        pub authority: Option<flatbuffers::WIPOffset<AssetAuthority<'a>>>,
        pub owner: Option<flatbuffers::WIPOffset<AssetOwner<'a>>>,
        pub collection: Option<flatbuffers::WIPOffset<AssetCollection<'a>>>,
        pub other_known_owners: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssetOwner<'a>>>,
            >,
        >,
    }
    impl<'a> Default for AssetCompleteDetailsArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssetCompleteDetailsArgs {
                pubkey: None,
                static_details: None,
                dynamic_details: None,
                authority: None,
                owner: None,
                collection: None,
                other_known_owners: None,
            }
        }
    }

    pub struct AssetCompleteDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssetCompleteDetailsBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssetCompleteDetails::VT_PUBKEY,
                pubkey,
            );
        }
        #[inline]
        pub fn add_static_details(
            &mut self,
            static_details: flatbuffers::WIPOffset<AssetStaticDetails<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssetStaticDetails>>(
                AssetCompleteDetails::VT_STATIC_DETAILS,
                static_details,
            );
        }
        #[inline]
        pub fn add_dynamic_details(
            &mut self,
            dynamic_details: flatbuffers::WIPOffset<AssetDynamicDetails<'b>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssetDynamicDetails>>(
                AssetCompleteDetails::VT_DYNAMIC_DETAILS,
                dynamic_details,
            );
        }
        #[inline]
        pub fn add_authority(&mut self, authority: flatbuffers::WIPOffset<AssetAuthority<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssetAuthority>>(
                AssetCompleteDetails::VT_AUTHORITY,
                authority,
            );
        }
        #[inline]
        pub fn add_owner(&mut self, owner: flatbuffers::WIPOffset<AssetOwner<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssetOwner>>(
                AssetCompleteDetails::VT_OWNER,
                owner,
            );
        }
        #[inline]
        pub fn add_collection(&mut self, collection: flatbuffers::WIPOffset<AssetCollection<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssetCollection>>(
                AssetCompleteDetails::VT_COLLECTION,
                collection,
            );
        }
        #[inline]
        pub fn add_other_known_owners(
            &mut self,
            other_known_owners: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssetOwner<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssetCompleteDetails::VT_OTHER_KNOWN_OWNERS,
                other_known_owners,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> AssetCompleteDetailsBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            AssetCompleteDetailsBuilder { fbb_: _fbb, start_: start }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssetCompleteDetails<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssetCompleteDetails<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssetCompleteDetails");
            ds.field("pubkey", &self.pubkey());
            ds.field("static_details", &self.static_details());
            ds.field("dynamic_details", &self.dynamic_details());
            ds.field("authority", &self.authority());
            ds.field("owner", &self.owner());
            ds.field("collection", &self.collection());
            ds.field("other_known_owners", &self.other_known_owners());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `AssetCompleteDetails`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_asset_complete_details_unchecked`.
    pub fn root_as_asset_complete_details(
        buf: &[u8],
    ) -> Result<AssetCompleteDetails, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<AssetCompleteDetails>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `AssetCompleteDetails` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_asset_complete_details_unchecked`.
    pub fn size_prefixed_root_as_asset_complete_details(
        buf: &[u8],
    ) -> Result<AssetCompleteDetails, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<AssetCompleteDetails>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `AssetCompleteDetails` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_asset_complete_details_unchecked`.
    pub fn root_as_asset_complete_details_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<AssetCompleteDetails<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<AssetCompleteDetails<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `AssetCompleteDetails` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_asset_complete_details_unchecked`.
    pub fn size_prefixed_root_as_asset_complete_details_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<AssetCompleteDetails<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<AssetCompleteDetails<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a AssetCompleteDetails and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `AssetCompleteDetails`.
    pub unsafe fn root_as_asset_complete_details_unchecked(buf: &[u8]) -> AssetCompleteDetails {
        flatbuffers::root_unchecked::<AssetCompleteDetails>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed AssetCompleteDetails and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `AssetCompleteDetails`.
    pub unsafe fn size_prefixed_root_as_asset_complete_details_unchecked(
        buf: &[u8],
    ) -> AssetCompleteDetails {
        flatbuffers::size_prefixed_root_unchecked::<AssetCompleteDetails>(buf)
    }
    #[inline]
    pub fn finish_asset_complete_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<AssetCompleteDetails<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_asset_complete_details_buffer<
        'a,
        'b,
        A: flatbuffers::Allocator + 'a,
    >(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<AssetCompleteDetails<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod Asset
